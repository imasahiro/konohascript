diff --git include/konoha1/konoha_t.h include/konoha1/konoha_t.h
index 1cd6b59..5c1ad52 100644
--- include/konoha1/konoha_t.h
+++ include/konoha1/konoha_t.h
@@ -823,6 +823,9 @@ typedef struct {
 #define KNH_SYSTEM          (ctx->sys)
 #define knh_Object_sweep    knh_Object_RCsweep
 
+struct kStmtExpr;
+typedef void (*fMethod_compile)(CTX, struct kMethod *, struct kStmtExpr *);
+
 typedef struct kshare_t {
 	/* system table */
 	const knh_ClassTBL_t    **ClassTBL;
@@ -894,6 +897,10 @@ typedef struct kshare_t {
 	knh_cond_t				 *stop_cond;
 	knh_cond_t				 *start_cond;
 	knh_cond_t				 *close_cond;
+
+	/* CompilerAPI */
+	struct kObject *konoha_compiler;
+	fMethod_compile compilerAPI;
 } kshare_t ;
 
 #define KNH_ASSERT_CTX0(ctx)   KNH_ASSERT((ctx)->ctxid == 0)
diff --git src/lang/asm.c src/lang/asm.c
index 289fafe..671ddf0 100644
--- src/lang/asm.c
+++ src/lang/asm.c
@@ -2906,7 +2906,12 @@ void knh_Method_asm(CTX ctx, kMethod *mtd, kStmtExpr *stmtB, knh_Ftyping typing)
 	void knh_LLVMMethod_asm(CTX ctx, kMethod *mtd, kStmtExpr *stmtP);
 	knh_LLVMMethod_asm(ctx, mtd, stmtB);
 #else
-	Method_compile(ctx, mtd, stmtB);
+	/* CompilerAPI */
+	if (IS_NOTNULL(ctx->share->konoha_compiler)) {
+		ctx->share->compilerAPI(ctx, mtd, stmtB);
+	} else {
+		Method_compile(ctx, mtd, stmtB);
+	}
 #endif /* K_USING_LLVM */
 }
 
diff --git src/lang/script.c src/lang/script.c
index bee5502..fbd5c2e 100644
--- src/lang/script.c
+++ src/lang/script.c
@@ -365,6 +365,9 @@ void knh_Script_setNSName(CTX ctx, kScript* scr, kString *nsname)
 	KNH_SETv(ctx, ((knh_ClassTBL_t*)O_cTBL(scr))->lname, CWB_newString(ctx, cwb, SPOL_ASCII));
 }
 
+typedef void (*knh_Fpkgcomplete)(CTX);
+
+/* ------------------------------------------------------------------------ */
 kstatus_t knh_loadPackage(CTX ctx, kbytes_t pkgname)
 {
 	kstatus_t status = K_CONTINUE;
@@ -389,6 +392,12 @@ kstatus_t knh_loadPackage(CTX ctx, kbytes_t pkgname)
 				scr = ctx->gma->scr;
 				KNH_SETv(ctx, ctx->gma->scr, newscr);
 				status = knh_InputStream_load(ctx, in, uline);
+				if (newscr->ns->gluehdr) {
+					void *p = newscr->ns->gluehdr;
+					knh_Fpkgcomplete pkgcomplete = (knh_Fpkgcomplete) knh_dlsym(ctx, p, "complete", NULL, 1/*isTest*/);
+					if (pkgcomplete)
+						pkgcomplete(ctx);
+				}
 				KNH_SETv(ctx, ctx->gma->scr, scr);
 			}
 		}
diff --git src/main/context.c src/main/context.c
index 2ceda5f..3e51ff9 100644
--- src/main/context.c
+++ src/main/context.c
@@ -352,6 +352,11 @@ static kcontext_t* new_RootContext(void)
 	share->ctx0 = ctx;
 	knh_GammaBuilder_init(ctx);  // initalize gamma->gf, reported by uh
 	knh_initBuiltInPackage(ctx, knh_getLoaderAPI());
+
+	/* CompilerAPI */
+	KNH_INITv(share->konoha_compiler, KNH_NULL);
+	share->compilerAPI = NULL;
+
 	share->contextCounter = 1;
 	share->threadCounter = 1;
 	share->stopCounter = 0;
@@ -543,12 +548,17 @@ static kObject **share_reftrace(CTX ctx, kshare_t *share FTRARG)
 		}
 		KNH_ADDNNREF(ctx, ct->constPoolMapNULL);
 	}
+
+	/* CompilerAPI */
+	KNH_ADDREF(ctx, share->konoha_compiler);
 	return tail_;
 }
 
 static void share_free(CTX ctx, kshare_t *share)
 {
 	size_t i;
+	/* CompilerAPI */
+	share->compilerAPI = NULL;
 	KNH_FREE(ctx, (void*)share->EventTBL, SIZEOF_TEXPT(ctx->share->capacityEventTBL));
 	share->EventTBL = NULL;
 	KNH_FREE(ctx, share->tString, SIZEOF_TSTRING);
